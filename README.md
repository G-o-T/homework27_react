# homework27_react

## 1. Как вы думаете, чем плохо задание атрибута компонента `key` функцией Math.random()?

key необходим, чтобы определять уникальность компонентов при обновлении. Функция Math.random() генерирует рандомное (случайное) число от 0 до 1. Даже если ее дорабоать так, чтобы получалилось натуральное число, все равно такой ключ останется нестабильным. В таком случае возможен излишний перерендер компонентов, пострадает производительность

## 2. Как будет выглядеть [этот](https://www.notion.so/27-ea715ee9a7414d88916c15cec7a71515?pvs=21) пример, если мы кроме id будем передавать ещё один параметр title?

классовые компоненты не даются мне совершенно. С удовольствием посмотрю ответ


## 3. В чём отличие VirtualDOM от обычного DOM?

DOM - объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять (напрямую связан с реальным отображением на экране). Виртуальный DOM - это абстрактное представление структуры DOM в виде JavaScript-объектов. Можно назвать его промежуточным звеном между компонентами React и реальным DOM.

VirtualDOM призван сократить количество изменений реального DOM, чтобы улучшить производительность. Это происходит за счет следующего: при изменении состояния компонента React создает новый виртуальный DOM, сравнивает его с предыдущим состоянием и выявляет минимальное количество изменений, которые необходимо применить к реальному DOM. 

## 4. В каком порядке выйдут сообщения в консоли и почему?
    
    ```jsx
    handleChange = () => {
    	console.log('foo');
    
    	this.setState({
    		checked: !this.state.checked, 
    		},
    		()=>{console.log('baz')}
    	);
    	console.log('bar') 
    };
    ```
    
    Метод setState является асинхронным, следовательно, предположу, что будет такой вывод:
    foo
    bar
    baz
    Второй аргумент у функции setState (функция обратного вызова) будет вызываться после выполнения функции setState и отрисовки компонента.

## 5. Какую проблему решает использование рефов?

React напрямую с DOM не взаимодействует, а иногда надо решать связанные  этим задачи (запустить прогрывание медиа, выделить текст, установить фокус, прокрутить страницу и т.д.). Так, рефы позволяют получить доступ к конкретным DOM-элементам, которые управляются компонентом. 
Кроме того, доступ может потребоваться при интеграции со сторонними библиотеками, для анимаций. Но реф - это не панацея, их надо использовать по-минимуму. Для взаимодействия между компонентами стоит использовать состояние и пропсы.

## 6. Как вы думаете, почему вызов методов ребёнка из родительского компонента противоречит философии реакта?

В React есть парадигма однонаправленного потока данных: родительские компоненты передают данные дочерним компонентам. С помощью этого можно создавать повторно используемые компоненты и поддерживать их независимо друг от друга. Если вызвать метод ребенка из родительского компонента, этот принцип нарушится, усложнится взаимодействие между компонентами.Т.к. родительский компонент будет затрагивать внутреннюю логику ребенка. А в Реакте компонеты должны быть максимально изолированы и независимы. Кроме того, вызов методов ребенка из родительского компонента может затруднить отслеживание изменений 

## 7. Можно ли с помощью хука `useRef` передать `ref` дочерним элементам? 

Да, можно, но так делать не стоит, т.е. может привести к нарушению принципов однонаправленного потока данных. Лучше передавать данные через props, чтобы  взаимодействие между компонентами было предсказуемым.

## 8. Что даёт нам использование кастомных хуков?

Перечислю несколько преимуществ:
- Повторное использование кода. Кастомные хуки позволяют выделить общую логику или функциональность из компонентов и переиспользовать ее в разных частях приложения;
- Улучшение читаемости кода. В кастомный хук можно вынести сложную логику компонента, код станет понятнее;
- Разделение ответственности. С помощью кастомных хуков код можно разделить на более мелкие модули, что способствует поддержке и распределению обязанностей между разными частями приложения;
- Изоляция состояния. С использованием хуков можно изолировать состояние и его изменения внутри компонента, что делает его более предсказуемым и упростит отладку;
- Создание абстракций. Можно создать хук с более высокоуровневыми абстракциями для обработки определенных задач. Например, работа с асинхронными запросами или управление анимациями;
- Улучшение тестирования. Код из кастомного хука легче тестировать через юнит-тесты;
- Соблюдение принципов хорошей архитектуры. С их помощью можно следовать принципу разделения интерфейса и реализации, что способствует созданию более устойчивых и масштабируемых приложений.